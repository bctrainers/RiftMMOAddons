
local type = type
local pairs = pairs
local ipairs = ipairs
local assert = assert
local error = error
local getmetatable = getmetatable
local setmetatable = setmetatable
local insert = table.insert
local remove = table.remove
local yield = coroutine.yield
local wrap = coroutine.wrap

require 'utils'
local isnil = utils.isnil
local istable = utils.istable
local isstring = utils.isstring
local tablestring = utils.tablestring
local totable = utils.totable

module(...) --, package.seeall)

--print('Loading ' .. _NAME)

function iterkeys(tbl, typ)
--[=[ typ: (optional)
      The type of keys to iterate. May be one of the following:
        'n' - all keys of type 'number', this is the default
        'h' - hash keys, that is, keys not of type 'number'
        'a' - all keys, as generated by pairs
        's' - sequential keys, as generated by ipairs
]=]
  return wrap(function()
    if typ == nil or typ == 'n' then
      for k in pairs(tbl) do if type(k) == 'number' then yield(k) end end
    elseif typ == 'h' then
      for k in pairs(tbl) do if type(k) ~= 'number' then yield(k) end end
    elseif typ == 'a' then
      for k in pairs(tbl) do yield(k) end
    elseif typ == 's' then
      for k in ipairs(tbl) do yield(k) end
    else
      error('Invalid key specification.')
end end) end

function keys(tbl, typ, sort, comp)
  local out = totable(iterkeys(tbl, typ))
  if sort then table.sort(out, comp) end
  return out
end

function itervalues(tbl, typ)
  return wrap(function()
    if typ == nil or typ == 'n' then
      for k, v in pairs(tbl) do if type(k) == 'number' then yield(v) end end
    elseif typ == 'h' then
      for k, v in pairs(tbl) do if type(k) ~= 'number' then yield(v) end end
    elseif typ == 'a' then
      for _, v in pairs(tbl) do yield(v) end
    elseif typ == 's' then
      for _, v in ipairs(tbl) do yield(v) end
    else
      error('Invalid key specification.')
end end) end

function values(tbl, typ, sort, comp)
  local out = totable(itervalues(tbl, typ))
  if sort then table.sort(out, comp) end
  return out
end

function constructor(obj, constructorname)
  local new = obj[constructorname or 'new']
  return function(...) return new(obj, ...) end
end


--[=[  Base object type  ]=]--


Object = {iterkeys = iterkeys, keys = keys,
          itervalues = itervalues, values = values,
          __tostring = tablestring, classes = {},
          insert = insert, remove = remove,
          constructor = constructor}

Object.classes[Object], Object.classes['Object'] = 'Object', Object

function Object:new(o)
  o = o or {}
  self.__index = self
  return setmetatable(o, self)
end

function class(name, obj, ...)
  if not type(name) == 'string' then error('expected argument #1 to be string, not ' .. type(name), 2) end
  local classes = Object.classes
  local parent, cls = classes[obj]
  if parent then
    parent = istable(parent) and parent or obj
    cls = parent:new(...)
  else
    if isnil(obj) or istable(obj) then
      cls = Object:new(obj)
    else
      error('could not find parent class for ' .. name, 2)
    end
  end
  classes[cls], classes[name] = name, cls
  return cls
end

function isa(cls, obj)
  local classes = Object.classes
  assert(classes[cls], 'Argument #1 is not a recognized class.')
  if isstring(obj) then obj = classes[obj] end
  while true do
    if obj == cls or classes[obj] == cls then
      return true
    elseif not obj then
      return false
    else
      obj = getmetatable(obj)
    end
  end
end
